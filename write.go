package lake

import (
	"context"
	"fmt"

	"github.com/hkloudou/lake/v2/internal/index"
	"github.com/hkloudou/lake/v2/internal/merge"
	"github.com/hkloudou/lake/v2/internal/trace"
)

// WriteRequest represents a write request
type WriteRequest struct {
	Catalog   string    // Catalog name
	Field     string    // JSON path (e.g., "user.profile.name")
	Body      []byte    // JSON body to write (raw bytes from network)
	MergeType MergeType // Merge strategy (Replace, RFC7396, or RFC6902)
}

// WriteResult represents the write result
type WriteResult struct {
	TsSeqID   string // Generated timestamp_seqid
	Timestamp int64  // Unix timestamp
	SeqID     int64  // Sequence ID
}

// Write writes data to the catalog
// Timestamp and sequence ID are auto-generated by Redis
//
// Merge Types:
// - MergeTypeReplace (0): Simple field replacement
// - MergeTypeRFC7396 (1): RFC 7396 JSON Merge Patch (field-level or root-level)
// - MergeTypeRFC6902 (2): RFC 6902 JSON Patch (field-level or root-level)
//
// Field parameter:
// - For Replace/RFC7396: specifies the target field (empty "" means root document)
// - For RFC6902: empty "" means operations apply to root, non-empty means operations scope to that field
//
// Body parameter:
// - Raw JSON bytes (typically from HTTP request body)
// - No additional marshaling/unmarshaling overhead
// - Examples:
//   - String value: []byte(`"Alice"`)
//   - Number value: []byte(`30`)
//   - Object value: []byte(`{"age":30}`)
//   - RFC7396 patch: []byte(`{"age":31,"city":null}`)
//   - RFC6902 patch: []byte(`[{"op":"add","path":"/a","value":1}]`)
func (c *Client) Write(ctx context.Context, req WriteRequest) (*WriteResult, error) {
	tr := trace.FromContext(ctx)

	if err := merge.ValidateFieldPath(req.Field); err != nil {
		return nil, err
	}

	// Ensure initialized before operation
	if err := c.ensureInitialized(ctx); err != nil {
		return nil, err
	}
	tr.RecordSpan("Write.Init")

	// Step 1: Atomically get TimeSeqID and pre-commit to Redis (pending state)
	tsSeq, pendingMember, err := c.writer.GetTimeSeqIDAndPreCommit(ctx, req.Catalog, req.Field, req.MergeType)
	if err != nil {
		return nil, fmt.Errorf("failed to generate timeseq and precommit: %w", err)
	}
	tr.RecordSpan("Write.PreCommit", map[string]any{
		"tsSeq":  tsSeq.String(),
		"seqID":  tsSeq.SeqID,
		"member": pendingMember,
	})

	// Step 2: Write to storage
	if c.storage == nil {
		return nil, fmt.Errorf("storage not initialized")
	}
	storageKey := c.storage.MakeDeltaKey(req.Catalog, tsSeq, int(req.MergeType))
	if err := c.storage.Put(ctx, storageKey, req.Body); err != nil {
		// Rollback: remove pending member from Redis
		// catalogKey := c.writer.MakeCatalogKey(req.Catalog)
		// c.rdb.ZRem(ctx, catalogKey, pendingMember)
		tr.RecordSpan("Write.Rollback")
		return nil, fmt.Errorf("failed to write to storage: %w", err)
	}
	tr.RecordSpan("Write.StoragePut", map[string]any{
		"key":  storageKey,
		"size": len(req.Body),
	})

	// Step 3: Atomically commit (remove pending, add committed)
	committedMember := index.EncodeDeltaMember(req.Field, tsSeq.String(), req.MergeType)
	err = c.writer.Commit(ctx, req.Catalog, pendingMember, committedMember, tsSeq.Score())
	if err != nil {
		return nil, fmt.Errorf("failed to commit: %w", err)
	}
	tr.RecordSpan("Write.Commit")

	return &WriteResult{
		TsSeqID:   tsSeq.String(),
		Timestamp: tsSeq.Timestamp,
		SeqID:     tsSeq.SeqID,
	}, nil
}
