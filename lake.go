package lake

import (
	"context"
	"encoding/json"
	"fmt"
	"sync"

	jsonpatch "github.com/evanphx/json-patch/v5"
	"github.com/hkloudou/lake/v2/internal/config"
	"github.com/hkloudou/lake/v2/internal/index"
	"github.com/hkloudou/lake/v2/internal/merge"
	"github.com/hkloudou/lake/v2/internal/snapshot"
	"github.com/hkloudou/lake/v2/internal/storage"
	"github.com/redis/go-redis/v9"
	"github.com/tidwall/gjson"
	"github.com/tidwall/sjson"
)

// Client is the main interface for Lake v2
type Client struct {
	rdb       *redis.Client
	writer    *index.Writer
	reader    *index.Reader
	merger    *merge.Engine
	configMgr *config.Manager

	// Lazy-loaded components
	mu      sync.RWMutex
	storage storage.Storage
	snapMgr *snapshot.Manager
	config  *config.Config
}

// Option is a function that configures the client
type Option struct {
	Storage storage.Storage
}

// NewLake creates a new Lake client with the given Redis URL
// Config is loaded lazily on first operation
func NewLake(metaUrl string, opts ...func(*Option)) *Client {
	// Parse Redis URL
	redisOpt, err := redis.ParseURL(metaUrl)
	if err != nil {
		// Fallback to treating it as an address
		redisOpt = &redis.Options{
			Addr: metaUrl,
		}
	}

	rdb := redis.NewClient(redisOpt)

	// Apply options
	option := &Option{}
	for _, opt := range opts {
		opt(option)
	}

	writer := index.NewWriter(rdb)
	reader := index.NewReader(rdb)
	merger := merge.NewEngine()
	configMgr := config.NewManager(rdb)

	client := &Client{
		rdb:       rdb,
		writer:    writer,
		reader:    reader,
		merger:    merger,
		configMgr: configMgr,
		storage:   option.Storage, // May be nil, will be loaded lazily
	}

	return client
}

// ensureInitialized ensures storage and snapMgr are initialized
// Loads config from Redis if not already loaded
func (c *Client) ensureInitialized(ctx context.Context) error {
	c.mu.RLock()
	if c.storage != nil && c.snapMgr != nil {
		c.mu.RUnlock()
		return nil
	}
	c.mu.RUnlock()

	c.mu.Lock()
	defer c.mu.Unlock()

	// Double-check after acquiring write lock
	if c.storage != nil && c.snapMgr != nil {
		return nil
	}

	// Load config and initialize storage if not provided
	if c.storage == nil {
		// Load config from Redis if not already loaded
		if c.config == nil {
			cfg, err := c.configMgr.Load(ctx)
			if err != nil {
				return fmt.Errorf("failed to load config from Redis (lake.setting): %w", err)
			}
			c.config = cfg
		}

		// Create storage from config - must succeed, no fallback
		stor, err := c.config.CreateStorage()
		if err != nil {
			return fmt.Errorf("failed to create %s storage: %w", c.config.Storage, err)
		}
		c.storage = stor

		// Set index prefix based on config: Storage:Name
		prefix := fmt.Sprintf("%s:%s", c.config.Storage, c.config.Name)
		c.writer.SetPrefix(prefix)
		c.reader.SetPrefix(prefix)
	}

	// Initialize snapshot manager
	if c.snapMgr == nil {
		c.snapMgr = snapshot.NewManager(c.storage, c.reader, c.writer)
	}

	return nil
}

// WriteRequest represents a write request
type WriteRequest struct {
	Catalog   string          // Catalog name
	Field     string          // JSON path (e.g., "user.profile.name")
	Value     any             // Value to write
	MergeType index.MergeType // Merge strategy (Replace or Merge)
}

// WriteResult represents the write result
type WriteResult struct {
	TsSeqID   string // Generated timestamp_seqid
	Timestamp int64  // Unix timestamp
	SeqID     int64  // Sequence ID
}

// Write writes data to the catalog
// Timestamp and sequence ID are auto-generated by Redis
func (c *Client) Write(ctx context.Context, req WriteRequest) (*WriteResult, error) {
	// Ensure initialized before operation
	if err := c.ensureInitialized(ctx); err != nil {
		return nil, err
	}

	// Marshal value to JSON
	data, err := json.Marshal(req.Value)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal value: %w", err)
	}

	// Generate time+seqid and add to index (atomically)
	tsSeq, err := c.writer.AddWithTimeSeq(ctx, req.Catalog, req.Field, req.MergeType)
	if err != nil {
		return nil, fmt.Errorf("failed to add to index: %w", err)
	}

	// Write to storage with filename: catalog/{ts}_{seqid}_{mergetype}.json
	if c.storage == nil {
		return nil, fmt.Errorf("storage not initialized")
	}
	key := storage.MakeDataKey(req.Catalog, tsSeq, int(req.MergeType))
	if err := c.storage.Put(ctx, key, data); err != nil {
		// Rollback: remove from Redis index (best effort)
		// TODO: implement proper rollback mechanism
		return nil, fmt.Errorf("failed to write to storage: %w", err)
	}

	return &WriteResult{
		TsSeqID:   tsSeq.String(),
		Timestamp: tsSeq.Timestamp,
		SeqID:     tsSeq.SeqID,
	}, nil
}

func (c *Client) readData(ctx context.Context, list *ListResult) ([]byte, error) {
	// Ensure initialized before operation
	if err := c.ensureInitialized(ctx); err != nil {
		return nil, err
	}
	var baseData = []byte("{}")
	if list.LatestSnap != nil {
		key := storage.MakeSnapKey(list.catalog, list.LatestSnap.StartTsSeq, list.LatestSnap.StopTsSeq)
		data, err := c.storage.Get(ctx, key)
		if err != nil {
			return nil, err
		}
		baseData = data
	}
	resultData, err := c.mergeEntries(ctx, list.catalog, baseData, list.Entries)
	if err != nil {
		return nil, err
	}
	if len(list.Entries) > 0 {
		nextSnap := list.NextSnap()
		_, err := list.client.snapMgr.Save(ctx, list.catalog, nextSnap.StartTsSeq, nextSnap.StopTsSeq, resultData)
		if err != nil {
			return nil, fmt.Errorf("failed to save snapshot: %w", err)
		}
	}
	return resultData, nil
}

// ReadRequest represents a read request
// type ReadRequest struct {
// 	Catalog      string // Catalog name
// 	GenerateSnap bool   // Whether to generate snapshot automatically
// }

// mergeEntries merges entries into baseData
// This is the single source of truth for data merging
func (c *Client) mergeEntries(ctx context.Context, catalog string, baseData []byte, entries []index.DataInfo) ([]byte, error) {
	merged := baseData
	for _, entry := range entries {
		// Read JSON from storage using new filename format
		key := storage.MakeDataKey(catalog, entry.TsSeq, int(entry.MergeType))
		data, err := c.storage.Get(ctx, key)
		if err != nil {
			continue // Skip missing data
		}

		// var value any
		// if err := json.Unmarshal(data, &value); err != nil {
		// 	continue // Skip invalid JSON
		// }

		// Merge using the strategy from entry
		// TODO: implement deep merge strategy for MergeTypeMerge
		// var strategy merge.Strategy
		mergaType := entry.MergeType
		if mergaType == index.MergeTypeMerge {
			// jsonpatch.me
			mergedPatrh, err := jsonpatch.MergePatch([]byte(gjson.GetBytes(merged, entry.Field).Raw), data)
			if err != nil {
				return nil, fmt.Errorf("failed to merge patch: %w", err)
			}
			data = mergedPatrh
			mergaType = index.MergeTypeReplace
		}

		switch mergaType {
		case index.MergeTypeReplace:
			merged, err = sjson.SetRawBytes([]byte(merged), entry.Field, data)
			if err != nil {
				return nil, fmt.Errorf("failed to set: %w", err)
			}
		default:
			return nil, fmt.Errorf("unknown merge type: %d", entry.MergeType)
			// strategy = merge.StrategySet
		}
	}
	return merged, nil
}

// Read reads and merges data from the catalog
func (c *Client) List(ctx context.Context, catalog string) (*ListResult, error) {
	// Ensure initialized before operation
	if err := c.ensureInitialized(ctx); err != nil {
		return nil, err
	}

	// Try to get existing snapshot
	snap, err := c.reader.GetLatestSnap(ctx, catalog)
	if err != nil {
		return nil, fmt.Errorf("failed to get snapshot: %w", err)
	}

	var allEntries []index.DataInfo

	if snap != nil {
		allEntries, err = c.reader.ReadSince(ctx, catalog, snap.StopTsSeq.Score())
		if err != nil {
			return nil, fmt.Errorf("failed to read all data: %w", err)
		}
	} else {
		// No snapshot, read all
		allEntries, err = c.reader.ReadAll(ctx, catalog)
		if err != nil {
			return nil, fmt.Errorf("failed to read all data: %w", err)
		}
	}
	return &ListResult{
		client:     c,
		catalog:    catalog,
		LatestSnap: snap,
		Entries:    allEntries, // Return all entries for debugging
	}, nil

	// Merge data from all entries (rebuild from scratch)
	// baseData := make(map[string]any)
	// entries := allEntries

	// Merge data (single source of truth)
	// merged, err := c.mergeEntries(ctx, catalog, snap, allEntries)
	// if err != nil {
	// 	return nil, err
	// }

	// result := &ReadResult{
	// 	Data:       merged,
	// 	LatestSnap: snap,
	// 	Entries:    allEntries, // Return all entries for debugging
	// }

	// Generate snapshot if requested
	// if req.GenerateSnap && len(allEntries) > 0 {
	// 	// Determine startTsSeq and stopTsSeq
	// 	var startTsSeq index.TimeSeqID
	// 	if snap != nil {
	// 		// Continue from previous snapshot
	// 		startTsSeq = snap.StopTsSeq
	// 	}

	// 	// Use the last entry's TsSeqID as stop point
	// 	lastEntry := allEntries[len(allEntries)-1]
	// 	// stopTsSeq, err := index.ParseTimeSeqID()
	// 	// if err != nil {
	// 	// 	return nil, fmt.Errorf("failed to parse last entry TsSeqID: %w", err)
	// 	// }

	// 	// score := tsSeq.Score()

	// 	// Save snapshot metadata (time range only, no data)
	// 	newSnap, err := c.snapMgr.Save(ctx, req.Catalog, startTsSeq, lastEntry.TsSeq, lastEntry.TsSeq.Score())
	// 	if err == nil {
	// 		result.LatestSnap = &index.SnapInfo{
	// 			StartTsSeq: newSnap.StartTsSeq,
	// 			StopTsSeq:  newSnap.StopTsSeq,
	// 			Score:      lastEntry.TsSeq.Score(),
	// 		}
	// 	}
	// }

	// return result, nil
}

// GetConfig returns the current config (loads from Redis if needed)
// DEPRECATED: Temporarily disabled. DO NOT DELETE this code.
// Will be re-enabled after API stabilization.
/*
func (c *Client) GetConfig(ctx context.Context) (*config.Config, error) {
	c.mu.RLock()
	if c.config != nil {
		cfg := c.config
		c.mu.RUnlock()
		return cfg, nil
	}
	c.mu.RUnlock()

	// Load config
	cfg, err := c.configMgr.Load(ctx)
	if err != nil {
		return nil, err
	}

	c.mu.Lock()
	c.config = cfg
	c.mu.Unlock()

	return cfg, nil
}
*/

// UpdateConfig updates the config in Redis
// DEPRECATED: Temporarily disabled. DO NOT DELETE this code.
// Will be re-enabled after storage reinitialization logic is implemented.
/*
func (c *Client) UpdateConfig(ctx context.Context, cfg *config.Config) error {
	if err := c.configMgr.Save(ctx, cfg); err != nil {
		return err
	}

	// Update cached config
	c.mu.Lock()
	c.config = cfg
	// TODO: Reinitialize storage based on new config
	c.mu.Unlock()

	return nil
}
*/
